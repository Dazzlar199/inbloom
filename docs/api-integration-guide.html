<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>특별시 API & 통합 가이드</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=Noto+Sans+KR:wght@300;400;500;700;900&display=swap");

      :root {
        --primary: #18181b;
        --primary-light: #3f3f46;
        --primary-dark: #09090b;
        --accent: #52525b;
        --bg-light: #fafafa;
        --text-dark: #18181b;
        --text-gray: #52525b;
        --text-light: #a1a1aa;
        --border: #e4e4e7;
        --success: #10b981;
        --warning: #f59e0b;
        --danger: #ef4444;
        --info: #3b82f6;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html {
        scroll-behavior: smooth;
      }

      body {
        font-family: "Inter", "Noto Sans KR", -apple-system, BlinkMacSystemFont,
          sans-serif;
        background: #f4f4f5;
        color: var(--text-dark);
        line-height: 1.7;
        letter-spacing: -0.02em;
      }

      .page {
        width: 210mm;
        min-height: 297mm;
        padding: 15mm 20mm 25mm 20mm;
        margin: 20px auto;
        background: white;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        page-break-after: always;
        border-radius: 4px;
        position: relative;
      }

      .cover {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        min-height: 257mm;
      }

      .cover-badge {
        display: inline-block;
        background: var(--primary);
        color: white;
        padding: 8px 24px;
        border-radius: 30px;
        font-size: 14px;
        font-weight: 500;
        margin-bottom: 30px;
      }

      .cover-title {
        font-size: 42px;
        font-weight: 900;
        color: var(--text-dark);
        margin-bottom: 16px;
        line-height: 1.3;
      }

      .cover-subtitle {
        font-size: 20px;
        color: var(--text-gray);
        margin-bottom: 40px;
      }

      .section-header {
        margin-bottom: 30px;
        padding-bottom: 20px;
        border-bottom: 3px solid var(--primary);
      }

      .section-badge {
        display: inline-block;
        background: var(--primary);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        margin-bottom: 12px;
      }

      .section-title {
        font-size: 28px;
        font-weight: 700;
        color: var(--text-dark);
        margin-bottom: 8px;
      }

      h3 {
        font-size: 18px;
        font-weight: 700;
        color: var(--primary-dark);
        margin: 24px 0 12px 0;
        padding: 0 0 12px 12px;
        border-left: 4px solid var(--primary);
      }

      h4 {
        font-size: 16px;
        font-weight: 600;
        margin: 20px 0 10px 0;
      }

      p {
        font-size: 14px;
        margin-bottom: 12px;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin: 16px 0;
        font-size: 13px;
      }

      th,
      td {
        padding: 12px 16px;
        text-align: left;
        border: 1px solid var(--border);
      }

      th {
        background: var(--primary);
        color: white;
        font-weight: 600;
      }

      tr:nth-child(even) {
        background: var(--bg-light);
      }

      .alert {
        padding: 16px 20px;
        border-radius: 8px;
        margin: 16px 0;
        font-size: 13px;
      }

      .alert-info {
        background: #eff6ff;
        border-left: 4px solid #3b82f6;
        color: #1e3a8a;
      }

      .alert-warning {
        background: #fffbeb;
        border-left: 4px solid #f59e0b;
        color: #92400e;
      }

      .alert-success {
        background: #ecfdf5;
        border-left: 4px solid #10b981;
        color: #065f46;
      }

      .alert-danger {
        background: #fef2f2;
        border-left: 4px solid #ef4444;
        color: #991b1b;
      }

      .alert-title {
        font-weight: 600;
        margin-bottom: 6px;
      }

      ul,
      ol {
        margin: 12px 0 12px 24px;
        font-size: 14px;
      }

      ol.numbered-list {
        list-style: decimal;
        margin: 16px 0 16px 32px;
      }

      li {
        margin: 8px 0;
      }

      .checklist {
        list-style: none;
        margin: 16px 0;
      }

      .checklist li {
        padding: 10px 0 10px 32px;
        position: relative;
        border-bottom: 1px solid var(--border);
      }

      .checklist li:before {
        content: "☐";
        position: absolute;
        left: 0;
        color: var(--primary);
        font-size: 16px;
      }

      .page-number {
        position: absolute;
        bottom: 15mm;
        right: 25mm;
        font-size: 12px;
        color: var(--text-light);
      }

      .sidebar {
        position: fixed;
        left: 20px;
        top: 50%;
        transform: translateY(-50%);
        width: 240px;
        max-height: 80vh;
        overflow-y: auto;
        background: white;
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
        z-index: 1000;
      }

      .sidebar-title {
        font-size: 14px;
        font-weight: 700;
        color: var(--primary);
        margin-bottom: 16px;
        padding-bottom: 12px;
        border-bottom: 2px solid var(--primary);
      }

      .sidebar-nav {
        list-style: none;
      }

      .sidebar-nav li {
        margin: 4px 0;
      }

      .sidebar-nav a {
        display: block;
        padding: 8px 12px;
        font-size: 13px;
        color: var(--text-gray);
        text-decoration: none;
        border-radius: 6px;
        transition: all 0.2s;
      }

      .sidebar-nav a:hover {
        background: var(--bg-light);
        color: var(--primary);
      }

      .sidebar-nav a.active {
        background: var(--primary);
        color: white;
      }

      code {
        background: #f3f4f6;
        padding: 2px 6px;
        border-radius: 4px;
        font-family: "SF Mono", "Monaco", "Consolas", monospace;
        font-size: 13px;
        color: var(--text-dark);
      }

      pre {
        background: #1e293b;
        color: #e2e8f0;
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 16px;
        margin: 16px 0;
        overflow-x: auto;
        font-family: "SF Mono", "Monaco", "Consolas", monospace;
        font-size: 12px;
        line-height: 1.6;
        page-break-inside: avoid;
      }

      pre code {
        background: none;
        padding: 0;
        color: inherit;
      }

      @media (max-width: 1400px) {
        .sidebar {
          display: none;
        }
      }

      @media print {
        .sidebar {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <!-- 사이드바 네비게이션 -->
    <div class="sidebar">
      <div class="sidebar-title">목차</div>
      <ul class="sidebar-nav">
        <li><a href="#chapter-01">제1장: API 개요</a></li>
        <li><a href="#chapter-02">제2장: FastAPI 구조</a></li>
        <li><a href="#chapter-03">제3장: Supabase API</a></li>
        <li><a href="#chapter-04">제4장: 외부 서비스 연동</a></li>
        <li><a href="#chapter-05">제5장: 웹훅 처리</a></li>
        <li><a href="#chapter-06">제6장: 클라이언트 연동</a></li>
        <li><a href="#chapter-07">제7장: API 문서화</a></li>
        <li><a href="#chapter-08">제8장: 에러 처리</a></li>
      </ul>
    </div>

    <!-- 표지 -->
    <div class="page">
      <div class="cover">
        <div class="cover-badge">API & Integration Guide</div>
        <h1 class="cover-title">특별시<br />API & 통합 가이드</h1>
        <p class="cover-subtitle">
          API 설계, 외부 서비스 연동, 웹훅 처리 가이드
        </p>

        <div
          style="
            margin-top: 40px;
            padding: 24px 40px;
            background: var(--bg-light);
            border-radius: 16px;
          "
        >
          <p><strong>버전:</strong> 1.0</p>
          <p><strong>작성일:</strong> 2026년 1월 2일</p>
          <p><strong>대상:</strong> 개발팀 (백엔드, 프론트엔드)</p>
          <p>
            <strong>범위:</strong> FastAPI, Supabase, 외부 서비스 연동, 웹훅,
            클라이언트 연동
          </p>
        </div>
      </div>
    </div>

    <!-- 제1장: API 개요 -->
    <div class="page" id="chapter-01">
      <div class="section-header">
        <div class="section-badge">Chapter 01</div>
        <h2 class="section-title">API 개요</h2>
      </div>

      <h3>1.1. API 아키텍처</h3>

      <p>
        특별시는 <strong>3계층 API 아키텍처</strong>를 사용합니다:
      </p>

      <table>
        <thead>
          <tr>
            <th>계층</th>
            <th>기술</th>
            <th>역할</th>
            <th>사용 사례</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>1. 클라이언트</strong></td>
            <td>Flutter, Next.js</td>
            <td>사용자 인터페이스</td>
            <td>앱, 웹 브라우저</td>
          </tr>
          <tr>
            <td><strong>2. API Gateway</strong></td>
            <td>Supabase, FastAPI</td>
            <td>비즈니스 로직 처리</td>
            <td>인증, 데이터 CRUD, AI 처리</td>
          </tr>
          <tr>
            <td><strong>3. 외부 서비스</strong></td>
            <td>토스페이먼츠, OpenAI 등</td>
            <td>특수 기능 제공</td>
            <td>결제, AI 분석</td>
          </tr>
        </tbody>
      </table>

      <h3>1.2. API 설계 원칙</h3>

      <h4>1.2.1. RESTful 원칙</h4>

      <ul class="checklist">
        <li>리소스 기반 URL 설계 (명사 사용, 동사 지양)</li>
        <li>HTTP 메서드 의미에 맞게 사용 (GET, POST, PUT, DELETE)</li>
        <li>상태 코드 적절히 사용 (200, 201, 400, 401, 404, 500)</li>
        <li>JSON 형식으로 요청/응답</li>
        <li>버전 관리 (/api/v1/)</li>
      </ul>

      <h4>1.2.2. API 네이밍 규칙</h4>

      <table>
        <thead>
          <tr>
            <th>규칙</th>
            <th>예시</th>
            <th>설명</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>리소스는 복수형</strong></td>
            <td>/api/v1/users</td>
            <td>단수형 /user 지양</td>
          </tr>
          <tr>
            <td><strong>하위 리소스는 경로로</strong></td>
            <td>/api/v1/users/{id}/matchings</td>
            <td>쿼리 파라미터 지양</td>
          </tr>
          <tr>
            <td><strong>동사는 HTTP 메서드로</strong></td>
            <td>POST /api/v1/payments/confirm</td>
            <td>GET /confirm-payment 지양</td>
          </tr>
          <tr>
            <td><strong>소문자와 하이픈 사용</strong></td>
            <td>/api/v1/service-providers</td>
            <td>카멜케이스, 언더스코어 지양</td>
          </tr>
        </tbody>
      </table>

      <h3>1.3. API 버전 관리</h3>

      <p>API 버전은 URL 경로에 포함합니다:</p>

      <pre><code># 버전 관리 방식
/api/v1/users          # 현재 버전
/api/v2/users          # 새 버전 (하위 호환성 깨질 때)

# 헤더 방식 (사용하지 않음)
# Accept: application/vnd.api+json;version=1</code></pre>

      <div class="alert alert-info">
        <div class="alert-title">버전 변경 전략</div>
        <ul style="margin-top: 8px">
          <li><strong>메이저 버전:</strong> 하위 호환성 깨질 때 (v1 → v2)</li>
          <li><strong>기존 버전 유지:</strong> 최소 6개월간 이전 버전 지원</li>
          <li><strong>마이그레이션 가이드:</strong> 버전 변경 시 가이드 제공</li>
          <li><strong>Deprecation:</strong> 제거 예정 API는 3개월 전 공지</li>
        </ul>
      </div>

      <h3>1.4. API 응답 형식</h3>

      <h4>1.4.1. 성공 응답</h4>

      <pre><code># 단일 리소스
{
  "data": {
    "id": "uuid",
    "name": "홍길동",
    "email": "user@example.com"
  }
}

# 리스트
{
  "data": [
    {"id": "uuid1", "name": "홍길동"},
    {"id": "uuid2", "name": "김철수"}
  ],
  "pagination": {
    "page": 1,
    "limit": 20,
    "total": 100,
    "total_pages": 5
  }
}

# 생성 성공
{
  "data": {
    "id": "uuid",
    "name": "홍길동"
  },
  "message": "User created successfully"
}</code></pre>

      <h4>1.4.2. 에러 응답</h4>

      <pre><code># 400 Bad Request
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid input data",
    "details": [
      {
        "field": "email",
        "message": "Invalid email format"
      }
    ]
  }
}

# 401 Unauthorized
{
  "error": {
    "code": "UNAUTHORIZED",
    "message": "Authentication required"
  }
}

# 404 Not Found
{
  "error": {
    "code": "NOT_FOUND",
    "message": "Resource not found"
  }
}

# 500 Internal Server Error
{
  "error": {
    "code": "INTERNAL_ERROR",
    "message": "An internal error occurred"
  }
}</code></pre>

      <div class="page-number">1</div>
    </div>

    <!-- 제2장: FastAPI 구조 -->
    <div class="page" id="chapter-02">
      <div class="section-header">
        <div class="section-badge">Chapter 02</div>
        <h2 class="section-title">FastAPI 구조</h2>
      </div>

      <h3>2.1. 프로젝트 구조</h3>

      <pre><code>apps/fastapi/
├── main.py                 # 애플리케이션 진입점
├── config.py              # 설정 (환경 변수)
├── database.py            # Supabase 연결
├── dependencies.py        # 의존성 (인증 등)
│
├── routers/               # API 라우터
│   ├── __init__.py
│   ├── auth.py           # 인증 (Supabase Auth 연동)
│   ├── users.py          # 사용자 관리
│   ├── providers.py      # 프리랜서 관리
│   ├── portfolios.py     # 포트폴리오
│   ├── matchings.py      # 매칭 관리
│   ├── messages.py       # 메시지 (채팅)
│   ├── reviews.py        # 리뷰
│   ├── credits.py        # 크레딧 시스템
│   └── payments.py       # 결제 (토스페이먼츠)
│
├── models/                # 데이터 모델 (SQLAlchemy, 선택적)
│   ├── __init__.py
│   ├── user.py
│   └── provider.py
│
├── schemas/               # Pydantic 스키마 (요청/응답)
│   ├── __init__.py
│   ├── user.py
│   ├── provider.py
│   └── payment.py
│
├── services/              # 비즈니스 로직
│   ├── __init__.py
│   ├── auth_service.py   # 인증 로직
│   ├── payment_service.py # 결제 로직 (토스페이먼츠)
│   ├── matching_service.py # 매칭 로직
│   └── ai_service.py     # AI 처리 (OpenAI, CLIP)
│
├── utils/                 # 유틸리티
│   ├── __init__.py
│   ├── security.py       # 보안 관련 (JWT 검증 등)
│   ├── validators.py     # 입력 검증
│   └── helpers.py        # 헬퍼 함수
│
└── tests/                 # 테스트
    ├── __init__.py
    ├── test_auth.py
    └── test_payments.py</code></pre>

      <h3>2.2. main.py 구조</h3>

      <pre><code># apps/fastapi/main.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from routers import (
    auth, users, providers, portfolios,
    matchings, messages, reviews, credits, payments
)
from config import settings

app = FastAPI(
    title="특별시 API",
    description="특별시 (The Special Time) API 문서",
    version="1.0.0",
    docs_url="/docs",  # Swagger UI
    redoc_url="/redoc"  # ReDoc
)

# CORS 설정
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 라우터 등록
app.include_router(auth.router, prefix="/api/v1/auth", tags=["auth"])
app.include_router(users.router, prefix="/api/v1/users", tags=["users"])
app.include_router(providers.router, prefix="/api/v1/providers", tags=["providers"])
app.include_router(portfolios.router, prefix="/api/v1/portfolios", tags=["portfolios"])
app.include_router(matchings.router, prefix="/api/v1/matchings", tags=["matchings"])
app.include_router(messages.router, prefix="/api/v1/messages", tags=["messages"])
app.include_router(reviews.router, prefix="/api/v1/reviews", tags=["reviews"])
app.include_router(credits.router, prefix="/api/v1/credits", tags=["credits"])
app.include_router(payments.router, prefix="/api/v1/payments", tags=["payments"])

@app.get("/")
async def root():
    return {"message": "특별시 API", "version": "1.0.0"}

@app.get("/health")
async def health_check():
    return {"status": "healthy"}</code></pre>

      <h3>2.3. 라우터 예시 (payments.py)</h3>

      <pre><code># apps/fastapi/routers/payments.py
from fastapi import APIRouter, Depends, HTTPException, Header
from typing import Optional
from schemas.payment import PaymentConfirmRequest, PaymentResponse
from services.payment_service import PaymentService
from dependencies import get_current_user
from models.user import User

router = APIRouter()
payment_service = PaymentService()

@router.post("/confirm", response_model=PaymentResponse)
async def confirm_payment(
    request: PaymentConfirmRequest,
    current_user: User = Depends(get_current_user),
    authorization: Optional[str] = Header(None)
):
    """
    결제 승인 요청
    
    - **paymentKey**: 토스페이먼츠 결제 키
    - **orderId**: 주문 ID
    - **amount**: 결제 금액
    """
    try:
        # 서비스 로직 호출
        result = await payment_service.confirm_payment(
            payment_key=request.paymentKey,
            order_id=request.orderId,
            amount=request.amount,
            user_id=current_user.id
        )
        return result
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail="Payment confirmation failed")

@router.get("/history", response_model=list[PaymentResponse])
async def get_payment_history(
    current_user: User = Depends(get_current_user),
    page: int = 1,
    limit: int = 20
):
    """결제 내역 조회"""
    return await payment_service.get_payment_history(
        user_id=current_user.id,
        page=page,
        limit=limit
    )</code></pre>

      <h3>2.4. Pydantic 스키마 예시</h3>

      <pre><code># apps/fastapi/schemas/payment.py
from pydantic import BaseModel, Field, validator
from typing import Optional
from datetime import datetime

class PaymentConfirmRequest(BaseModel):
    """결제 승인 요청"""
    paymentKey: str = Field(..., description="토스페이먼츠 결제 키")
    orderId: str = Field(..., description="주문 ID", min_length=1)
    amount: int = Field(..., description="결제 금액", gt=0)
    
    @validator('amount')
    def validate_amount(cls, v):
        if v < 1000:
            raise ValueError('최소 결제 금액은 1,000원입니다')
        return v

class PaymentResponse(BaseModel):
    """결제 응답"""
    id: str
    orderId: str
    paymentKey: str
    amount: int
    status: str
    approvedAt: Optional[datetime] = None
    method: Optional[str] = None
    
    class Config:
        from_attributes = True</code></pre>

      <h3>2.5. 의존성 (인증)</h3>

      <pre><code># apps/fastapi/dependencies.py
from fastapi import Depends, HTTPException, Header
from typing import Optional
from supabase import create_client, Client
from config import settings

supabase: Client = create_client(
    settings.SUPABASE_URL,
    settings.SUPABASE_SERVICE_ROLE_KEY
)

async def get_current_user(authorization: Optional[str] = Header(None)):
    """
    JWT 토큰으로 현재 사용자 조회
    
    헤더 형식: Authorization: Bearer {token}
    """
    if not authorization:
        raise HTTPException(status_code=401, detail="Authorization header missing")
    
    try:
        # Bearer 제거
        token = authorization.replace("Bearer ", "")
        
        # Supabase에서 사용자 정보 조회
        user_response = supabase.auth.get_user(token)
        user = user_response.user
        
        if not user:
            raise HTTPException(status_code=401, detail="Invalid token")
        
        return user
    except Exception as e:
        raise HTTPException(status_code=401, detail="Authentication failed")</code></pre>

      <div class="page-number">2</div>
    </div>

    <!-- 제3장: Supabase API -->
    <div class="page" id="chapter-03">
      <div class="section-header">
        <div class="section-badge">Chapter 03</div>
        <h2 class="section-title">Supabase API</h2>
      </div>

      <h3>3.1. Supabase 클라이언트 설정</h3>

      <h4>3.1.1. Python (FastAPI)</h4>

      <pre><code># apps/fastapi/database.py
from supabase import create_client, Client
from config import settings

# 공개 키 (클라이언트용)
supabase_anon: Client = create_client(
    settings.SUPABASE_URL,
    settings.SUPABASE_ANON_KEY
)

# 서비스 역할 키 (서버용, RLS 무시)
supabase_service: Client = create_client(
    settings.SUPABASE_URL,
    settings.SUPABASE_SERVICE_ROLE_KEY
)</code></pre>

      <div class="alert alert-warning">
        <div class="alert-title">키 사용 가이드</div>
        <ul style="margin-top: 8px">
          <li>
            <strong>ANON_KEY:</strong> 클라이언트에서 사용 (RLS 적용)
          </li>
          <li>
            <strong>SERVICE_ROLE_KEY:</strong> 서버에서만 사용 (RLS 무시,
            절대 노출 금지)
          </li>
        </ul>
      </div>

      <h4>3.1.2. Flutter</h4>

      <pre><code>// lib/services/supabase_service.dart
import 'package:supabase_flutter/supabase_flutter.dart';

class SupabaseService {
  static Future<void> initialize() async {
    await Supabase.initialize(
      url: 'https://xxxxx.supabase.co',
      anonKey: 'your-anon-key',
    );
  }
  
  static SupabaseClient get client => Supabase.instance.client;
}

// 사용 예시
final supabase = SupabaseService.client;

// 데이터 조회
final response = await supabase
    .from('users')
    .select()
    .eq('id', userId)
    .single();

// 데이터 삽입
await supabase
    .from('users')
    .insert({'name': '홍길동', 'email': 'user@example.com'});

// 데이터 업데이트
await supabase
    .from('users')
    .update({'name': '김철수'})
    .eq('id', userId);

// 데이터 삭제
await supabase
    .from('users')
    .delete()
    .eq('id', userId);</code></pre>

      <h4>3.1.3. Next.js</h4>

      <pre><code>// lib/supabase/client.ts
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!

export const supabase = createClient(supabaseUrl, supabaseAnonKey)

// 사용 예시
import { supabase } from '@/lib/supabase/client'

// 데이터 조회
const { data, error } = await supabase
  .from('users')
  .select('*')
  .eq('id', userId)
  .single()

// 데이터 삽입
const { data, error } = await supabase
  .from('users')
  .insert({ name: '홍길동', email: 'user@example.com' })</code></pre>

      <h3>3.2. 인증 (Supabase Auth)</h3>

      <h4>3.2.1. 이메일/비밀번호 로그인</h4>

      <pre><code># Python (FastAPI)
from supabase import create_client

supabase = create_client(url, key)

# 회원가입
response = supabase.auth.sign_up({
    "email": "user@example.com",
    "password": "secure_password"
})

# 로그인
response = supabase.auth.sign_in_with_password({
    "email": "user@example.com",
    "password": "secure_password"
})

# JWT 토큰은 response.session.access_token에 있음</code></pre>

      <pre><code>// Flutter
import 'package:supabase_flutter/supabase_flutter.dart';

final supabase = Supabase.instance.client;

// 회원가입
final response = await supabase.auth.signUp(
  email: 'user@example.com',
  password: 'secure_password',
);

// 로그인
final response = await supabase.auth.signInWithPassword(
  email: 'user@example.com',
  password: 'secure_password',
);

// 토큰은 자동으로 관리됨 (Supabase Client가 자동으로 헤더에 추가)</code></pre>

      <h4>3.2.2. 소셜 로그인</h4>

      <pre><code>// Flutter - 카카오 로그인 (별도 SDK 필요)
import 'package:kakao_flutter_sdk_user/kakao_flutter_sdk_user.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

// 1. 카카오 로그인
final oauthToken = await UserApi.instance.loginWithKakaoTalk();

// 2. 카카오 ID 토큰 획득
final idToken = await UserApi.instance.idToken;

// 3. Supabase에 ID 토큰 전달
final response = await supabase.auth.signInWithIdToken(
  provider: Provider.kakao,
  idToken: idToken!,
);

// 네이버, Apple, 구글은 Supabase Auth에서 직접 지원 (별도 SDK 불필요)
await supabase.auth.signInWithOAuth(
  Provider.google,
  redirectTo: 'myapp://login-callback',
);</code></pre>

      <h3>3.3. Row Level Security (RLS)</h3>

      <p>
        RLS는 <strong>데이터베이스 레벨에서 접근 제어</strong>를 수행합니다.
        자세한 내용은 <strong>보안 가이드</strong>를 참조하세요.
      </p>

      <pre><code>-- RLS 활성화
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- 정책 생성: 본인만 조회
CREATE POLICY "Users can view own profile"
ON users FOR SELECT
USING (auth.uid() = id);

-- 정책 생성: 본인만 수정
CREATE POLICY "Users can update own profile"
ON users FOR UPDATE
USING (auth.uid() = id);

-- 정책 생성: 관련자만 조회 (매칭)
CREATE POLICY "Users can view own matchings"
ON matchings FOR SELECT
USING (
  auth.uid() = user_id OR
  auth.uid() = provider_id
);</code></pre>

      <h3>3.4. Realtime (실시간 데이터)</h3>

      <h4>3.4.1. Flutter Realtime 구독</h4>

      <pre><code>// lib/services/realtime_service.dart
import 'package:supabase_flutter/supabase_flutter.dart';

final supabase = Supabase.instance.client;

// 채팅 메시지 실시간 구독
final subscription = supabase
    .channel('messages')
    .onPostgresChanges(
      event: PostgresChangeEvent.insert,
      schema: 'public',
      table: 'messages',
      filter: PostgresChangeFilter(
        type: PostgresChangeFilterType.eq,
        column: 'matching_id',
        value: matchingId,
      ),
      callback: (payload) {
        // 새 메시지 처리
        final message = payload.newRecord;
        print('New message: ${message['content']}');
      },
    )
    .subscribe();

// 구독 해제
await supabase.removeChannel(subscription);</code></pre>

      <h3>3.5. Storage (파일 업로드)</h3>

      <pre><code>// Flutter - 이미지 업로드
import 'package:supabase_flutter/supabase_flutter.dart';
import 'dart:io';

final supabase = Supabase.instance.client;

// 파일 업로드
final file = File('/path/to/image.jpg');
final fileBytes = await file.readAsBytes();

final fileName = '${userId}_${DateTime.now().millisecondsSinceEpoch}.jpg';

await supabase.storage
    .from('profiles')  // 버킷 이름
    .upload(fileName, fileBytes, fileOptions: FileOptions(
      contentType: 'image/jpeg',
      upsert: false,
    ));

// 파일 URL 가져오기
final url = supabase.storage
    .from('profiles')
    .getPublicUrl(fileName);</code></pre>

      <div class="page-number">3</div>
    </div>

    <!-- 제4장: 외부 서비스 연동 -->
    <div class="page" id="chapter-04">
      <div class="section-header">
        <div class="section-badge">Chapter 04</div>
        <h2 class="section-title">외부 서비스 연동</h2>
      </div>

      <h3>4.1. 토스페이먼츠 (결제)</h3>

      <h4>4.1.1. SDK 설치</h4>

      <pre><code># Python (FastAPI)
pip install toss-payments

# 또는 HTTP 요청 직접 사용
import httpx
import os

TOSS_SECRET_KEY = os.getenv("TOSS_SECRET_KEY")
TOSS_CLIENT_KEY = os.getenv("TOSS_CLIENT_KEY")</code></pre>

      <h4>4.1.2. 결제 승인</h4>

      <pre><code># apps/fastapi/services/payment_service.py
import httpx
from config import settings

class PaymentService:
    async def confirm_payment(
        self,
        payment_key: str,
        order_id: str,
        amount: int,
        user_id: str
    ):
        """
        결제 승인 요청
        """
        url = "https://api.tosspayments.com/v1/payments/confirm"
        headers = {
            "Authorization": f"Basic {settings.TOSS_SECRET_KEY}",
            "Content-Type": "application/json"
        }
        data = {
            "paymentKey": payment_key,
            "orderId": order_id,
            "amount": amount
        }
        
        async with httpx.AsyncClient() as client:
            response = await client.post(url, headers=headers, json=data)
            response.raise_for_status()
            return response.json()</code></pre>

      <div class="alert alert-danger">
        <div class="alert-title">보안 주의사항</div>
        <ul style="margin-top: 8px">
          <li>
            <strong>서버 사이드 검증 필수:</strong> 클라이언트에서 결제 승인
            요청을 직접 하지 않고, 서버를 통해 처리
          </li>
          <li>
            <strong>금액 검증:</strong> DB에 저장된 주문 금액과 일치하는지
            확인
          </li>
          <li>
            <strong>중복 결제 방지:</strong> 이미 승인된 주문 ID는 재승인
            불가
          </li>
        </ul>
      </div>

      <h4>4.1.3. 결제 취소</h4>

      <pre><code># 결제 취소
async def cancel_payment(
    self,
    payment_key: str,
    cancel_reason: str,
    cancel_amount: Optional[int] = None
):
    """결제 취소"""
    url = f"https://api.tosspayments.com/v1/payments/{payment_key}/cancel"
    headers = {
        "Authorization": f"Basic {settings.TOSS_SECRET_KEY}",
        "Content-Type": "application/json"
    }
    data = {
        "cancelReason": cancel_reason
    }
    if cancel_amount:
        data["cancelAmount"] = cancel_amount
    
    async with httpx.AsyncClient() as client:
        response = await client.post(url, headers=headers, json=data)
        response.raise_for_status()
        return response.json()</code></pre>

      <h3>4.2. OpenAI API (AI 상담)</h3>

      <h4>4.2.1. GPT-4o-mini 사용</h4>

      <pre><code># apps/fastapi/services/ai_service.py
import openai
from config import settings

openai.api_key = settings.OPENAI_API_KEY

class AIService:
    async def generate_recommendations(
        self,
        user_preferences: dict,
        portfolio_tags: list[str]
    ) -> list[dict]:
        """
        사용자 선호도 기반 매칭 추천 생성
        """
        prompt = f"""
        사용자 선호도: {user_preferences}
        포트폴리오 태그: {portfolio_tags}
        
        위 정보를 바탕으로 웨딩 프리랜서 추천 이유를 설명해주세요.
        """
        
        response = await openai.ChatCompletion.acreate(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": "You are a wedding planning assistant."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7,
            max_tokens=500
        )
        
        return response.choices[0].message.content</code></pre>

      <h3>4.3. Hugging Face CLIP (이미지 유사도 - Phase 2)</h3>

      <pre><code># apps/fastapi/services/ai_service.py
import requests
from config import settings

class AIService:
    async def get_image_embedding(self, image_url: str) -> list[float]:
        """
        이미지를 벡터로 변환 (CLIP)
        """
        api_url = "https://api-inference.huggingface.co/models/openai/clip-vit-base-patch32"
        headers = {
            "Authorization": f"Bearer {settings.HUGGINGFACE_API_KEY}"
        }
        
        # 이미지 다운로드
        response = requests.get(image_url)
        image_bytes = response.content
        
        # CLIP API 호출
        response = requests.post(
            api_url,
            headers=headers,
            data=image_bytes
        )
        response.raise_for_status()
        return response.json()
    
    async def calculate_similarity(
        self,
        embedding1: list[float],
        embedding2: list[float]
    ) -> float:
        """
        코사인 유사도 계산
        """
        import numpy as np
        
        vec1 = np.array(embedding1)
        vec2 = np.array(embedding2)
        
        dot_product = np.dot(vec1, vec2)
        norm1 = np.linalg.norm(vec1)
        norm2 = np.linalg.norm(vec2)
        
        return dot_product / (norm1 * norm2)</code></pre>

      <h3>4.4. Firebase (푸시 알림)</h3>

      <pre><code># Python - Firebase Admin SDK
from firebase_admin import initialize_app, messaging
import firebase_admin

# 초기화 (한 번만)
if not firebase_admin._apps:
    cred = credentials.Certificate("path/to/serviceAccountKey.json")
    initialize_app(cred)

# 푸시 알림 전송
def send_push_notification(
    token: str,
    title: str,
    body: str,
    data: dict = None
):
    message = messaging.Message(
        notification=messaging.Notification(
            title=title,
            body=body
        ),
        data=data or {},
        token=token
    )
    
    response = messaging.send(message)
    return response</code></pre>

      <div class="page-number">4</div>
    </div>

    <!-- 제5장: 웹훅 처리 -->
    <div class="page" id="chapter-05">
      <div class="section-header">
        <div class="section-badge">Chapter 05</div>
        <h2 class="section-title">웹훅 처리</h2>
      </div>

      <h3>5.1. 토스페이먼츠 웹훅</h3>

      <h4>5.1.1. 웹훅 엔드포인트</h4>

      <pre><code># apps/fastapi/routers/payments.py
from fastapi import APIRouter, Request, HTTPException, Header
import hmac
import hashlib
import base64
from config import settings

router = APIRouter()

@router.post("/webhook")
async def handle_toss_webhook(
    request: Request,
    authorization: str = Header(None)
):
    """
    토스페이먼츠 웹훅 처리
    
    웹훅 이벤트:
    - payment.confirmed: 결제 승인
    - payment.canceled: 결제 취소
    - payment.failed: 결제 실패
    """
    # 1. 서명 검증 (보안 가이드 참조)
    body = await request.body()
    if not verify_webhook_signature(authorization, body):
        raise HTTPException(status_code=401, detail="Invalid signature")
    
    # 2. 웹훅 데이터 파싱
    webhook_data = await request.json()
    event_type = webhook_data.get("eventType")
    data = webhook_data.get("data")
    
    # 3. 이벤트 타입별 처리
    if event_type == "payment.confirmed":
        await handle_payment_confirmed(data)
    elif event_type == "payment.canceled":
        await handle_payment_canceled(data)
    elif event_type == "payment.failed":
        await handle_payment_failed(data)
    
    return {"status": "ok"}

async def handle_payment_confirmed(data: dict):
    """결제 승인 처리"""
    payment_key = data.get("paymentKey")
    order_id = data.get("orderId")
    amount = data.get("totalAmount")
    
    # DB에 결제 정보 저장
    # 주문 상태 업데이트
    # 크레딧 충전 (필요시)
    pass</code></pre>

      <h4>5.1.2. 웹훅 서명 검증</h4>

      <pre><code>def verify_webhook_signature(
    authorization: str,
    payload: bytes
) -> bool:
    """
    웹훅 서명 검증
    
    Authorization 헤더 형식: "Basic {signature}"
    """
    if not authorization or not authorization.startswith("Basic "):
        return False
    
    received_signature = authorization.replace("Basic ", "")
    
    # 서명 생성 (HMAC-SHA256)
    expected_signature = base64.b64encode(
        hmac.new(
            settings.TOSS_SECRET_KEY.encode(),
            payload,
            hashlib.sha256
        ).digest()
    ).decode()
    
    # 타이밍 공격 방지를 위한 상수 시간 비교
    return hmac.compare_digest(received_signature, expected_signature)</code></pre>

      <h4>5.1.3. 웹훅 URL 설정</h4>

      <div class="alert alert-info">
        <div class="alert-title">토스페이먼츠 대시보드 설정</div>
        <ul style="margin-top: 8px">
          <li>
            <strong>웹훅 URL:</strong>
            https://api.teukbyulsi.app/api/v1/payments/webhook
          </li>
          <li>
            <strong>이벤트 선택:</strong> payment.confirmed,
            payment.canceled, payment.failed
          </li>
          <li>
            <strong>테스트:</strong> 토스페이먼츠 테스트 도구로 웹훅 테스트
          </li>
        </ul>
      </div>

      <h3>5.2. Supabase 웹훅 (Database Webhooks)</h3>

      <h4>5.2.1. Supabase Edge Functions</h4>

      <p>
        Supabase는 <strong>Database Webhooks</strong>를 지원합니다. 테이블
        변경 시 HTTP 요청을 보낼 수 있습니다.
      </p>

      <pre><code>-- Supabase 대시보드에서 Webhook 생성
-- 테이블: matchings
-- 이벤트: INSERT, UPDATE
-- URL: https://api.teukbyulsi.app/api/v1/webhooks/supabase/matchings

-- 또는 Edge Function 사용 (권장)
-- supabase/functions/matchings-webhook/index.ts

import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

serve(async (req) => {
  const supabase = createClient(
    Deno.env.get('SUPABASE_URL') ?? '',
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  )
  
  const { record } = await req.json()
  
  // 매칭 생성 시 알림 전송 등
  // ...
  
  return new Response(JSON.stringify({ ok: true }), {
    headers: { 'Content-Type': 'application/json' },
  })
})</code></pre>

      <div class="page-number">5</div>
    </div>

    <!-- 제6장: 클라이언트 연동 -->
    <div class="page" id="chapter-06">
      <div class="section-header">
        <div class="section-badge">Chapter 06</div>
        <h2 class="section-title">클라이언트 연동</h2>
      </div>

      <h3>6.1. Flutter 연동</h3>

      <h4>6.1.1. HTTP 클라이언트 설정</h4>

      <pre><code>// lib/core/network/api_client.dart
import 'package:dio/dio.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class ApiClient {
  static final Dio _dio = Dio(BaseOptions(
    baseUrl: 'https://api.teukbyulsi.app/api/v1',
    connectTimeout: const Duration(seconds: 30),
    receiveTimeout: const Duration(seconds: 30),
    headers: {
      'Content-Type': 'application/json',
    },
  ));

  static void setupInterceptors() {
    _dio.interceptors.add(InterceptorsWrapper(
      onRequest: (options, handler) {
        // JWT 토큰 자동 추가
        final session = Supabase.instance.client.auth.currentSession;
        if (session != null) {
          options.headers['Authorization'] = 'Bearer ${session.accessToken}';
        }
        return handler.next(options);
      },
      onError: (error, handler) {
        // 에러 처리
        if (error.response?.statusCode == 401) {
          // 토큰 만료, 재로그인 필요
        }
        return handler.next(error);
      },
    ));
  }

  static Dio get client => _dio;
}</code></pre>

      <h4>6.1.2. API 서비스 예시</h4>

      <pre><code>// lib/services/payment_service.dart
import 'package:dio/dio.dart';
import '../core/network/api_client.dart';

class PaymentService {
  final Dio _client = ApiClient.client;

  Future<Map<String, dynamic>> confirmPayment({
    required String paymentKey,
    required String orderId,
    required int amount,
  }) async {
    try {
      final response = await _client.post(
        '/payments/confirm',
        data: {
          'paymentKey': paymentKey,
          'orderId': orderId,
          'amount': amount,
        },
      );
      return response.data;
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  Future<List<Map<String, dynamic>>> getPaymentHistory({
    int page = 1,
    int limit = 20,
  }) async {
    try {
      final response = await _client.get(
        '/payments/history',
        queryParameters: {'page': page, 'limit': limit},
      );
      return List<Map<String, dynamic>>.from(response.data['data']);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  Exception _handleError(DioException error) {
    if (error.response != null) {
      final errorData = error.response!.data;
      return Exception(errorData['error']['message'] ?? 'Payment failed');
    }
    return Exception('Network error');
  }
}</code></pre>

      <h3>6.2. Next.js 연동</h3>

      <h4>6.2.1. API 라우트 (Server-Side)</h4>

      <pre><code>// app/api/payments/confirm/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'

export async function POST(request: NextRequest) {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    
    if (!user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }

    const body = await request.json()
    const { paymentKey, orderId, amount } = body

    // FastAPI 호출
    const response = await fetch('https://api.teukbyulsi.app/api/v1/payments/confirm', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${user.access_token}`, // Supabase JWT
      },
      body: JSON.stringify({ paymentKey, orderId, amount }),
    })

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}</code></pre>

      <h4>6.2.2. 클라이언트 컴포넌트</h4>

      <pre><code>// app/payments/page.tsx
'use client'

import { useState } from 'react'

export default function PaymentPage() {
  const [loading, setLoading] = useState(false)

  const handlePayment = async () => {
    setLoading(true)
    try {
      const response = await fetch('/api/payments/confirm', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          paymentKey: '...',
          orderId: '...',
          amount: 10000,
        }),
      })
      const data = await response.json()
      // 처리
    } catch (error) {
      console.error(error)
    } finally {
      setLoading(false)
    }
  }

  return (
    <button onClick={handlePayment} disabled={loading}>
      {loading ? 'Processing...' : 'Pay'}
    </button>
  )
}</code></pre>

      <h3>6.3. 에러 처리 패턴</h3>

      <h4>6.3.1. Flutter 에러 처리</h4>

      <pre><code>// lib/utils/error_handler.dart
class ApiException implements Exception {
  final String message;
  final int? statusCode;

  ApiException(this.message, [this.statusCode]);

  @override
  String toString() => message;
}

class ErrorHandler {
  static ApiException handle(DioException error) {
    if (error.response != null) {
      final statusCode = error.response!.statusCode;
      final errorData = error.response!.data;
      
      switch (statusCode) {
        case 400:
          return ApiException(errorData['error']['message'] ?? 'Bad request');
        case 401:
          return ApiException('Authentication required');
        case 403:
          return ApiException('Permission denied');
        case 404:
          return ApiException('Resource not found');
        case 500:
          return ApiException('Server error');
        default:
          return ApiException('Unknown error');
      }
    } else {
      return ApiException('Network error');
    }
  }
}</code></pre>

      <div class="page-number">6</div>
    </div>

    <!-- 제7장: API 문서화 -->
    <div class="page" id="chapter-07">
      <div class="section-header">
        <div class="section-badge">Chapter 07</div>
        <h2 class="section-title">API 문서화</h2>
      </div>

      <h3>7.1. OpenAPI/Swagger 자동 생성</h3>

      <p>
        FastAPI는 <strong>자동으로 OpenAPI 스키마를 생성</strong>합니다.
      </p>

      <pre><code># FastAPI 자동 생성 문서
# Swagger UI: http://localhost:8000/docs
# ReDoc: http://localhost:8000/redoc

from fastapi import FastAPI

app = FastAPI(
    title="특별시 API",
    description="특별시 (The Special Time) API 문서",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)</code></pre>

      <h3>7.2. API 문서 작성 가이드</h3>

      <h4>7.2.1. Docstring 활용</h4>

      <pre><code>@router.post("/confirm", response_model=PaymentResponse)
async def confirm_payment(
    request: PaymentConfirmRequest,
    current_user: User = Depends(get_current_user)
):
    """
    결제 승인 요청
    
    토스페이먼츠 결제 키를 사용하여 결제를 승인합니다.
    
    - **paymentKey**: 토스페이먼츠에서 발급한 결제 키
    - **orderId**: 주문 ID (중복 불가)
    - **amount**: 결제 금액 (원 단위)
    
    성공 시 결제 정보를 반환합니다.
    """
    pass</code></pre>

      <h4>7.2.2. Pydantic 스키마 문서화</h4>

      <pre><code>from pydantic import BaseModel, Field

class PaymentConfirmRequest(BaseModel):
    """결제 승인 요청 스키마"""
    
    paymentKey: str = Field(
        ...,
        description="토스페이먼츠 결제 키",
        example="tgen_202401011234567890"
    )
    orderId: str = Field(
        ...,
        description="주문 ID (고유값)",
        example="order_20240101_001",
        min_length=1
    )
    amount: int = Field(
        ...,
        description="결제 금액 (원)",
        example=10000,
        gt=0
    )</code></pre>

      <h3>7.3. API 문서 배포</h3>

      <table>
        <thead>
          <tr>
            <th>방법</th>
            <th>설명</th>
            <th>장단점</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Swagger UI (기본)</strong></td>
            <td>FastAPI 자동 생성 문서</td>
            <td>간단, 실시간 업데이트</td>
          </tr>
          <tr>
            <td><strong>ReDoc</strong></td>
            <td>FastAPI 자동 생성 문서 (다른 스타일)</td>
            <td>깔끔한 UI, 실시간 업데이트</td>
          </tr>
          <tr>
            <td><strong>Postman Collection</strong></td>
            <td>OpenAPI 스키마를 Postman으로 변환</td>
            <td>테스트 용이, 팀 공유</td>
          </tr>
          <tr>
            <td><strong>독립 문서 사이트</strong></td>
            <td>GitBook, Notion 등</td>
            <td>추가 설명 가능, 검색 용이</td>
          </tr>
        </tbody>
      </table>

      <h3>7.4. Postman Collection 생성</h3>

      <pre><code># OpenAPI 스키마 다운로드
# http://localhost:8000/openapi.json

# Postman에서 Import
# 1. Postman 열기
# 2. Import → Link
# 3. URL 입력: https://api.teukbyulsi.app/openapi.json
# 4. Import 클릭

# 또는 파일로 Import
# 1. openapi.json 파일 다운로드
# 2. Postman → Import → File
# 3. 파일 선택</code></pre>

      <div class="page-number">7</div>
    </div>

    <!-- 제8장: 에러 처리 -->
    <div class="page" id="chapter-08">
      <div class="section-header">
        <div class="section-badge">Chapter 08</div>
        <h2 class="section-title">에러 처리</h2>
      </div>

      <h3>8.1. HTTP 상태 코드</h3>

      <table>
        <thead>
          <tr>
            <th>코드</th>
            <th>의미</th>
            <th>사용 사례</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>200 OK</strong></td>
            <td>성공</td>
            <td>GET, PUT 요청 성공</td>
          </tr>
          <tr>
            <td><strong>201 Created</strong></td>
            <td>생성 성공</td>
            <td>POST 요청 성공 (리소스 생성)</td>
          </tr>
          <tr>
            <td><strong>400 Bad Request</strong></td>
            <td>잘못된 요청</td>
            <td>입력 검증 실패, 잘못된 파라미터</td>
          </tr>
          <tr>
            <td><strong>401 Unauthorized</strong></td>
            <td>인증 필요</td>
            <td>토큰 없음, 토큰 만료</td>
          </tr>
          <tr>
            <td><strong>403 Forbidden</strong></td>
            <td>권한 없음</td>
            <td>권한 부족, 접근 거부</td>
          </tr>
          <tr>
            <td><strong>404 Not Found</strong></td>
            <td>리소스 없음</td>
            <td>존재하지 않는 리소스</td>
          </tr>
          <tr>
            <td><strong>409 Conflict</strong></td>
            <td>충돌</td>
            <td>중복된 리소스, 상태 충돌</td>
          </tr>
          <tr>
            <td><strong>422 Unprocessable Entity</strong></td>
            <td>처리 불가</td>
            <td>Pydantic 검증 실패</td>
          </tr>
          <tr>
            <td><strong>500 Internal Server Error</strong></td>
            <td>서버 오류</td>
            <td>예상치 못한 서버 오류</td>
          </tr>
        </tbody>
      </table>

      <h3>8.2. 커스텀 예외 처리</h3>

      <pre><code># apps/fastapi/utils/exceptions.py
from fastapi import HTTPException, status

class PaymentException(HTTPException):
    def __init__(self, detail: str):
        super().__init__(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail={
                "code": "PAYMENT_ERROR",
                "message": detail
            }
        )

class InsufficientCreditsException(HTTPException):
    def __init__(self):
        super().__init__(
            status_code=status.HTTP_402_PAYMENT_REQUIRED,
            detail={
                "code": "INSUFFICIENT_CREDITS",
                "message": "Insufficient credits"
            }
        )

# 사용 예시
from utils.exceptions import PaymentException

if payment_amount > user_balance:
    raise PaymentException("Payment amount exceeds balance")</code></pre>

      <h3>8.3. 전역 예외 핸들러</h3>

      <pre><code># apps/fastapi/main.py
from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from pydantic import ValidationError

app = FastAPI()

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """Pydantic 검증 오류 처리"""
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            "error": {
                "code": "VALIDATION_ERROR",
                "message": "Invalid input data",
                "details": exc.errors()
            }
        }
    )

@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    """일반 예외 처리"""
    # 로깅
    logger.error(f"Unhandled exception: {exc}")
    
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={
            "error": {
                "code": "INTERNAL_ERROR",
                "message": "An internal error occurred"
            }
        }
    )</code></pre>

      <h3>8.4. 로깅</h3>

      <pre><code># apps/fastapi/utils/logger.py
import logging
from datetime import datetime

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/api.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

# 사용 예시
from utils.logger import logger

logger.info(f"Payment confirmed: {payment_key}")
logger.error(f"Payment failed: {error}", exc_info=True)</code></pre>

      <div
        style="
          margin-top: 60px;
          padding-top: 20px;
          border-top: 2px solid var(--border);
          text-align: center;
          color: var(--text-light);
        "
      >
        <p><strong>© 2026 The Special Time. All Rights Reserved.</strong></p>
        <p style="margin-top: 8px; font-size: 12px">
          본 가이드는 API 개발 및 외부 서비스 연동 시 참고용입니다. API는
          지속적으로 개선되므로 최신 문서를 확인하세요.
        </p>
        <p style="margin-top: 8px; font-size: 12px">
          보안 관련 내용은 <strong>보안 & 프라이버시 가이드</strong>를 참조하세요.
        </p>
      </div>

      <div class="page-number">8</div>
    </div>

    <script>
      const navLinks = document.querySelectorAll(".sidebar-nav a");
      const sections = document.querySelectorAll(".page[id]");

      function updateActiveNav() {
        let current = "";
        sections.forEach((section) => {
          const sectionTop = section.offsetTop;
          if (window.scrollY >= sectionTop - 200) {
            current = section.getAttribute("id");
          }
        });

        navLinks.forEach((link) => {
          link.classList.remove("active");
          if (link.getAttribute("href") === `#${current}`) {
            link.classList.add("active");
          }
        });
      }

      window.addEventListener("scroll", updateActiveNav);
      updateActiveNav();

      navLinks.forEach((link) => {
        link.addEventListener("click", (e) => {
          e.preventDefault();
          const targetId = link.getAttribute("href").substring(1);
          const targetSection = document.getElementById(targetId);
          if (targetSection) {
            targetSection.scrollIntoView({
              behavior: "smooth",
              block: "start",
            });
          }
        });
      });
    </script>
  </body>
</html>

